#!/usr/bin/python3
from __future__ import annotations
from typing import Dict, Any, List, Tuple
from Magics import macro
import argparse
import inspect
import logging
import sys
import os
import re
import fnmatch
import json
import yaml

map_params = {
    "subpage_map_projection": "cylindrical",
    "subpage_lower_left_longitude": -5.,
    "subpage_lower_left_latitude": 30.,
    "subpage_upper_right_longitude": 27.,
    "subpage_upper_right_latitude": 55.,
    # For an example of more, see skinnywms/plot/magics.py
}


class Recipe:
    """
    A parsed and validated recipe
    """
    def __init__(self, data: Dict[str, Any]):
        # Get the recipe name
        self.name = data.get("name", "unnamed recipe")

        # Get the list of input globs
        self.inputs: List[Tuple[str, str, re.Pattern]] = []
        for name, glob in data.get("inputs", {}).items():
            # Convert the globs into regular expressions
            regex = re.compile(fnmatch.translate(glob))
            self.inputs.append((name, glob, regex))
        if len(self.inputs) > 1:
            raise RuntimeError("Recipes with multiple inputs are not supported yet")

        # Get the recipe steps
        self.steps: List[Tuple[str, Dict[str, Any]]] = []
        for s in data.get("recipe", ()):
            if not isinstance(s, dict):
                raise RuntimeError("recipe step is not a dict")
            step = s.pop("step", None)
            if step is None:
                raise RuntimeError("recipe step does not contain a 'step' name")
            self.steps.append((step, s))

    def matches(self, path: str):
        """
        Check if the given path matches one of the recipe input regexps
        """
        # TODO: change this logic for multi-source recipes
        for name, glob, input_re in self.inputs:
            if input_re.match(path):
                return True
        return False

    def start_dish(self, src: str, dest: str):
        """
        Start an output for this recipe and the given source
        """
        dish = Dish(dest)
        # TODO: change this logic for multi-source recipes
        dish.sources[self.inputs[0][0]] = src
        return dish

    def prepare(self, dish: "Dish"):
        """
        Run all the steps of the recipe
        """
        chef = Chef(dish)

        for name, args in self.steps:
            meth = getattr(chef, name, None)
            if meth is None:
                raise RuntimeError("Recipe " + self.name + " uses unknown step " + name)
            meth(**args)

        chef.serve()

    def document(self, dest: str):
        with open(dest, "wt") as fd:
            print("#", self.name, file=fd)
            print(file=fd)
            print("## Inputs", file=fd)
            print(file=fd)
            for name, glob, input_re in self.inputs:
                print(f"* **{name}**: `{glob}`", file=fd)
            print(file=fd)
            print("## Steps", file=fd)
            print(file=fd)
            for name, args in self.steps:
                print(f"### {name}", file=fd)
                print(file=fd)
                print(inspect.getdoc(getattr(Chef, name)), file=fd)
                print(file=fd)
                if args:
                    print("With arguments:", file=fd)
                    print("```", file=fd)
                    # FIXME: dump as yaml?
                    print(json.dumps(args, indent=2), file=fd)
                    print("```", file=fd)
                print(file=fd)


class Recipes:
    """
    Repository of all known recipes
    """
    def __init__(self):
        self.recipes = []

    def load(self, path: str):
        """
        Load recipes from the given directory
        """
        for fn in os.listdir(path):
            if not fn.endswith(".yaml"):
                continue
            with open(os.path.join(path, fn), "rt") as fd:
                recipe = yaml.load(fd)
            self.recipes.append(Recipe(recipe))

    def document(self, path: str):
        """
        Generate markdown documentation for the recipes found in the given path
        """
        for fn in os.listdir(path):
            if not fn.endswith(".yaml"):
                continue
            with open(os.path.join(path, fn), "rt") as fd:
                recipe = yaml.load(fd)
            recipe = Recipe(recipe)
            recipe.document(os.path.join(path, fn) + ".md")

    def for_path(self, path: str):
        """
        Generate all recipes matching the given path
        """
        for recipe in self.recipes:
            if recipe.matches(path):
                yield recipe


class Dish:
    """
    Object holding the final output and intermediate data while the recipes are
    executed
    """
    def __init__(self, fname: str):
        # Settings of the PNG output
        self.output = macro.output(
            output_formats=['png'],
            output_name=fname,
            output_name_first_page_number="off",
        )
        # List of source paths by name
        self.sources: Dict[str, str] = {}
        # Loaded GRIB data
        self.gribs: Dict[str, Any] = {}
        # Elements passed after output to macro.plot
        self.parts = []


class Chef:
    def __init__(self, dish: Dish):
        self.dish = dish

    def add_basemap(self, params):
        """
        Add a base map
        """
        self.dish.parts.append(macro.mmap(**params))

    def add_coastlines_bg(self):
        """
        Add background coastlines
        """
        self.dish.parts.append(macro.mcoast(map_coastline_general_style="background"))

    def add_coastlines_fg(self):
        """
        Add foreground coastlines
        """
        self.dish.parts.append(macro.mcoast(map_coastline_general_style="foreground"))
        self.dish.parts.append(macro.mcoast(
            map_coastline_sea_shade_colour="#f2f2f2",
            map_grid="off",
            map_coastline_sea_shade="on",
            map_label="off",
            map_coastline_colour="#f2f2f2",
            map_coastline_resolution="medium",
        ))

    def add_grib(self, name: str):
        """
        Add a grib file
        """
        fname = self.dish.sources[name]
        grib = macro.mgrib(grib_input_file_name=fname)
        self.dish.gribs[name] = grib
        self.dish.parts.append(grib)

    def add_contour(self):
        """
        Add contouring of the previous data
        """
        self.dish.parts.append(
            macro.mcont(
                contour_automatic_setting="ecmwf",
            )
        )

    def add_grid(self):
        """
        Add a coordinates grid
        """
        self.dish.parts.append(
            macro.mcoast(map_coastline_general_style="grid"),
        )

    def add_boundaries(self):
        """
        Add a coordinates grid
        """
        self.dish.parts.append(
            macro.mcoast(map_coastline_general_style="boundaries"),
        )

    def serve(self):
        macro.plot(
            self.dish.output,
            *self.dish.parts,
        )


def main():
    default_styles = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), "styles"))
    if not os.path.isdir(default_styles):
        default_styles = "/usr/share/magics/styles/ecmwf"

    parser = argparse.ArgumentParser(description="Render model maps")
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("--styles", metavar="dir", action="store", default=default_styles, help="styles directory")
    parser.add_argument("--document-recipes", action="store_true", help="generate recipes documentation")
    parser.add_argument("workdir", metavar="dir", help="directory with the files to render")

    args = parser.parse_args()

    # Setup logging
    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)

    if args.document_recipes:
        recipes = Recipes()
        recipes.document(args.workdir)
    else:
        # Tell magics where it should take its default styles from
        os.environ["MAGICS_STYLE_PATH"] = args.styles
        # Tell magics not to print noisy banners
        os.environ["MAGPLUS_QUIET"] = "1"

        recipes = Recipes()
        recipes.load("recipes")

        # TODO: change this logic for multi-source recipes
        for dirpath, dirnames, filenames in os.walk(args.workdir):
            dirpath = dirpath[len(args.workdir):]
            for fn in filenames:
                path = os.path.join(dirpath, fn)
                for recipe in recipes.for_path(path):
                    print("Found recipe", recipe.name, "for", path)
                    src = os.path.join(args.workdir, dirpath, fn)
                    dest = os.path.join(args.workdir, dirpath, fn + ".png")
                    dish = recipe.start_dish(src, dest)
                    recipe.prepare(dish)
                    print("Rendered", src, "to", dest)


if __name__ == "__main__":
    main()
