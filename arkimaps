#!/usr/bin/python3
from __future__ import annotations
import arkimet
from typing import Optional
import contextlib
import argparse
import logging
import os
import sys
import time

log = logging.getLogger("arkimaps")


class Dispatcher:
    def __init__(self, workds: arkimet.dataset.Dataset):
        self.ds = workds
        self.writer = self.ds.writer()

    @contextlib.contextmanager
    def input(self, path: Optional[str] = None):
        """
        Open the binary input stream
        """
        if path is None:
            yield sys.stdin.buffer
        else:
            with open(path, "rb") as fd:
                yield fd

    def dispatch(self, md: arkimet.Metadata) -> bool:
        self.writer.acquire(md)
        return True

    def read(self, path: Optional[str] = None):
        """
        Read data from an input file, or standard input.

        The input file is the output of arki-query --inline, which is the same
        as is given as input to arkimet processors.
        """
        with self.input(path) as infd:
            # TODO: batch multiple writes together?
            arkimet.Metadata.read_bundle(infd, dest=self.dispatch)


@contextlib.contextmanager
def workds(session):
    # TODO: use TemporaryDirectory
    workdir = os.path.abspath("workdir")
    if not os.path.isdir(workdir):
        os.mkdir(workdir)

    config = arkimet.cfg.Sections()
    config["workdir"] = {
        "format": "grib",
        "step": "yearly",
        "name": "workdir",
        "path": workdir,
        "type": "iseg",
        "unique": "reftime, level, timerange, product",
        # TODO: add options to tell sqlite and file writes to be fast
        # and insecure; use eatmydata until then
    }

    with open(os.path.join(workdir, "config"), "wt") as fd:
        config["workdir"].write(fd)

    with session.dataset(cfg=config["workdir"]) as ds:
        yield ds


class LogCollector(logging.Handler):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.entries = []

    def emit(self, record: logging.LogRecord):
        entry = {
            'ts': time.clock_gettime_ns(time.CLOCK_REALTIME),
            'level': record.levelno,
            'msg': self.format(record),
            'name': record.name
        }
        self.entries.append(entry)


def main():
    default_styles = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), "styles"))
    if not os.path.isdir(default_styles):
        default_styles = "/usr/share/magics/styles/ecmwf"

    parser = argparse.ArgumentParser(description="Render model maps")
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("--styles", metavar="dir", action="store", default=default_styles, help="styles directory")
    args = parser.parse_args()

    # Setup logging
    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)

    # Collect log entries that we can then add to the output data
    log_collector = LogCollector()
    root_logger = logging.getLogger()
    root_logger.addHandler(log_collector)

    # Tell magics where it shuold take its default styles from
    os.environ["MAGICS_STYLE_PATH"] = args.styles
    # Tell magics not to print noisy banners
    os.environ["MAGPLUS_QUIET"] = "1"

    # Dispatch input products into a work dataset
    with arkimet.dataset.Session(force_dir_segments=True) as session:
        with workds(session) as ds:
            dispatcher = Dispatcher(ds)
            dispatcher.read()


if __name__ == "__main__":
    main()
